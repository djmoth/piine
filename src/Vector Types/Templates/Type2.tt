<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<# (string, string, int)[] types = 
{ 
("float", "Float", 4), 
("double", "Double", 8), 
("int", "Int", 4), 
("uint", "UInt", 4), 
("byte", "Byte", 1), 
("sbyte", "SByte", 1), 
("short", "Short", 2), 
("ushort", "UShort", 2), 
("long", "Long", 8), 
("ulong", "ULong", 8) 
}; #>

using System;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace piine
{
	<# foreach ((string dataType, string capitalizedDataType, int memorySize) in types) 
	{
	string typeName = capitalizedDataType + "2";
	string floatType = (dataType != "double" && dataType != "long" && dataType != "ulong") ? "float" : "double";
	string scalarType = (dataType == "float" || dataType == "double" || dataType == "long" || dataType == "ulong" || dataType == "uint") ? dataType : "int";
	#>

    [StructLayout (LayoutKind.Explicit, Size = <#=memorySize * 2#>)]
    public unsafe struct <#=typeName#> : IEquatable<<#=typeName#>>
    {
        public const int Size = 2;

        private static readonly <#=typeName#> zero = new <#=typeName#> (0);
        private static readonly <#=typeName#> one = new <#=typeName#> (1);
        private static readonly <#=typeName#> unitX = new <#=typeName#> (1, 0);
        private static readonly <#=typeName#> unitY = new <#=typeName#> (0, 1);

        public static ref readonly <#=typeName#> Zero => ref zero;
        public static ref readonly <#=typeName#> One => ref one;
        public static ref readonly <#=typeName#> UnitX => ref unitX;
        public static ref readonly <#=typeName#> UnitY => ref unitY;

        [FieldOffset (0)]
        private fixed <#=dataType#> components[Size];

        [FieldOffset (0)]
        public <#=dataType#> x;
        [FieldOffset (<#=memorySize#>)]
        public <#=dataType#> y;  

		public <#=scalarType#> Area => x * y;

        public <#=typeName#> (<#=dataType#> x, <#=dataType#> y)
        {
            this.x = x;
            this.y = y;
        }

        public <#=typeName#> (<#=dataType#> all)
        {
            x = all;
            y = all;
        }

        public <#=dataType#> this[int index]
        {
            get
            {
                if (index < 0 || index >= Size)
                    throw new ArgumentOutOfRangeException ("Index must be in the range 0-1, index was " + index);

                return components[index];
            }
            set
            {
                if (index < 0 || index >= Size)
                    throw new ArgumentOutOfRangeException ("Index must be in the range 0-1, index was " + index);

                components[index] = value;
            }
        }

        public <#=dataType#> GetUnsafe (int index) => components[index];

        public void SetUnsafe (int index, <#=dataType#> value) => components[index] = value;

        public static <#=typeName#> Normalize (<#=typeName#> v)
        {
            if (v == Zero)
                return Zero;

            <#=floatType#> oldMagnitude = v.Length ();
            v.x = (<#=dataType#>)(v.x / oldMagnitude);
            v.y = (<#=dataType#>)(v.y / oldMagnitude);

            return v;
        }

        public static <#=typeName#> Absolute (<#=typeName#> v) => new <#=typeName#> ((<#=dataType#>)Math.Abs ((<#=floatType#>)v.x), (<#=dataType#>)Math.Abs ((<#=floatType#>)v.y));

        public static <#=floatType#> Distance (<#=typeName#> a, <#=typeName#> b) => (a - b).Length ();

        public static <#=floatType#> Dot (<#=typeName#> a, <#=typeName#> b) => a.x * b.x + a.y * b.y;

		public <#=scalarType#> Sum () => x + y;

		public <#=floatType#> Length () => (<#=floatType#>)Math.Sqrt (LengthSquared ());

        public <#=floatType#> LengthSquared () => ((<#=floatType#>)x * x) + ((<#=floatType#>)y * y);

		public bool Contains (<#=dataType#> value) => x == value || y == value;

        public static explicit operator Vector2 (<#=typeName#> v) => new Vector2 ((float)v.x, (float)v.y);

        public static explicit operator <#=typeName#> (Vector2 v) => new <#=typeName#> ((<#=dataType#>)v.X, (<#=dataType#>)v.Y);

        public static implicit operator <#=typeName#> ((<#=dataType#> x, <#=dataType#> y) v) => new <#=typeName#> (v.x, v.y);

        public static implicit operator (<#=dataType#>, <#=dataType#>) (<#=typeName#> v) => (v.x, v.y);

        public static bool operator == (<#=typeName#> a, <#=typeName#> b) => a.x == b.x && a.y == b.y;

        public static bool operator != (<#=typeName#> a, <#=typeName#> b) => a.x != b.x || a.y != b.y;

        public unsafe static <#=typeName#> operator + (<#=typeName#> a, <#=typeName#> b) => new <#=typeName#> ((<#=dataType#>)(a.x + b.x), (<#=dataType#>)(a.y + b.y));

        public static <#=typeName#> operator - (<#=typeName#> a, <#=typeName#> b) => new <#=typeName#> ((<#=dataType#>)(a.x - b.x), (<#=dataType#>)(a.y - b.y));

		<# if (!new string[] { "byte", "ushort", "uint", "ulong" }.Contains (dataType)) { #>
public static <#=typeName#> operator - (<#=typeName#> v) => new <#=typeName#> ((<#=dataType#>)-v.x, (<#=dataType#>)-v.y);
		<# } #>

        public static <#=typeName#> operator * (<#=typeName#> a, <#=floatType#> b) => new <#=typeName#> ((<#=dataType#>)(a.x * b), (<#=dataType#>)(a.y * b));

        public static <#=typeName#> operator / (<#=typeName#> a, <#=floatType#> b) => new <#=typeName#> ((<#=dataType#>)(a.x / b), (<#=dataType#>)(a.y / b));

        public static bool operator > (<#=typeName#> a, <#=typeName#> b) => a.x > b.x && a.y > b.y;

        public static bool operator < (<#=typeName#> a, <#=typeName#> b) => a.x < b.x && a.y < b.y;

        public static bool operator >= (<#=typeName#> a, <#=typeName#> b) => a.x >= b.x && a.y >= b.y;

        public static bool operator <= (<#=typeName#> a, <#=typeName#> b) => a.x <= b.x && a.y <= b.y;

		public void Deconstruct (out <#=dataType#> x, out <#=dataType#> y)
		{
			x = this.x;
			y = this.y;
		}

        public override string ToString () => "(" + x + ", " + y + ")";

        public bool Equals (<#=typeName#> other) => this == other;

        public override bool Equals (object obj)
        {
            <#=typeName#>? v = obj as <#=typeName#>?;

            if (v != null)
                return v == this;
            else
                return false;
        }

		//Conversion to other vectors
		<# foreach ((string otherDataType, string otherCapitalizedDataType, _) in types) 
		{
			if (otherDataType.Equals (dataType))
				continue;

			string otherTypeName = otherCapitalizedDataType + "2";
		#>

		//<#=otherTypeName#>
public static explicit operator <#=typeName#> (<#=otherTypeName#> v) => new <#=typeName#> ((<#=dataType#>)v.x, (<#=dataType#>)v.y);

		<# } #>
    }
	<# } #>
}